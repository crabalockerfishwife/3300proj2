
<!DOCTYPE html>

<!-- Map generation code sourced from -->
<!-- https://medium.com/@andybarefoot/making-a-map-using-d3-js-8aa3637304ee -->

<html>
<head>
    <title> </title>
    <meta charset="utf-8" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/4.5.0/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js"></script>
    <script src="https://d3js.org/d3.v4.min.js"></script>

    <!-- Did not write this stylesheet -->
    <link rel = "stylesheet" type = "text/css" href = "not_written_style.css" />
    <link rel = "stylesheet" type = "text/css" href = "style.css" />
	<script src="https://use.fontawesome.com/releases/v5.0.10/js/all.js" integrity="sha384-slN8GvtUJGnv6ca26v8EzVaR9DC58QEwsIk9q1QXdCU8Yu8ck/tL/5szYlBbqmS+" crossorigin="anonymous"></script>

</head>


<body>
<div id="map-holder"></div>
    <script src="http://code.jquery.com/jquery-1.10.2.min.js"></script>
    <script src="http://cdn.leafletjs.com/leaflet-0.7.1/leaflet.js"></script>
	<script src="https://use.fontawesome.com/releases/v5.0.10/js/all.js" ></script>
    
	<!-- Our code to parse Empire and Colony Data -->
	<script src ="colonialismData.js"></script>
    
	<script>

// Code to populate the value array (of extinct languages) associated with an American country key
      function populate(americanCountries, rawExtinctData, americanCountriesWithLang) {
          var i;
          for (i = 0; i < americanCountries.length; i++) {
              //console.log(americanCountries[i]);
              var j;
              for (j = 0; j < rawExtinctData.length; j++) {
                  //console.log(rawExtinctData[j].countriesWithLang.split(", "));
                  if (rawExtinctData[j].countriesWithLang.split(", ").includes(americanCountries[i])){
                    try{
                      		americanCountriesWithLang[i].value.push(rawExtinctData[j].language+"|"+rawExtinctData[j].vulnerability+"|"+rawExtinctData[j].speakers);
                    } catch(e) {

                    }
                  }
              }
          }
          //console.log(americanCountries);
    }
	
    //Our code to parse the extinct language data
      function initialDataParsing(callback) {
      result = [];
      rawExtinctData = [];
      americanCountriesWithLang = [];
      americanCountries = [];
      
      function parseExtinctData(line) {
        return {
          language: line["Name in English"],
          countriesWithLang: line["Countries"],
          vulnerability: line["Degree of endangerment"],
          speakers: line["Number of speakers"]  
        };
      };
      
      function parseAmericanCountries(row) {    
        result.push(row["Country"]);
        return result;   
      };
      
      d3.csv("extinctlangs.csv", parseExtinctData, function(error, extinct){
        rawExtinctData = extinct;
      });
        
      d3.csv("AmericanCountries.csv", parseAmericanCountries, function(error, amer){
         americanCountries = result;
         var j = 0;
         americanCountries.forEach(function(){
            
         langArr = [];
         var k = 0;
         rawExtinctData.forEach(function() {
              
         if (rawExtinctData[k].countriesWithLang.includes(americanCountries[j])){
            langArr.push(rawExtinctData[k].language);
          }
            k++;
          });
            
          americanCountriesWithLang.push({key: americanCountries[j], value: langArr});
            j++;
            
          });
        
        });
      setTimeout(function() { callback(americanCountries, rawExtinctData, americanCountriesWithLang); }, 2000);
    }
    initialDataParsing(populate);


        //The following code was modelled of off: https://medium.com/@andybarefoot/making-a-map-using-d3-js-8aa3637304ee
		//However we have made extensive changes

        var tooltip = d3.select("body")
        .append("div")
        .style("position", "absolute")
        .style("top", "100px")
		.style("left", "18px")
        .style("z-index", "10")
		.style("background-color", "#F2F5EB")
        .attr("id", "info")
		.style("border-width", "1px")
		.style("border-color", "#360C10")
		.style("color", "#360C10")
		
      document.getElementById("info").innerHTML = 
        "<br> <br>Click on a North or South <br>American country to zoom. <br><br>Hover over one of these <br>countries to see a list of its <br>vulnerable and extinct <br>languages.<br><br>Language vulnerability is <br>indicated by color and the <br>number of speakers left. <br><br><text class='vulnerable'>&nbsp</text> : vulnerable<br><text class='definitely-endangered'>&nbsp</text> : definitely endangered<br><text class='severely-endangered'>&nbsp</text> : severely endangered <br><text class='critically-endangered'>&nbsp</text> : critically endangered<br><text class='extinct'>&nbsp</text> : extinct<br>  <br>Click on a European country <br> to see its colonies.";
		
		
        // DEFINE VARIABLES
        // Define size of map group
        w = 2500;
        h = 1400;
        // variables for catching min and max zoom factors
        var minZoom;
        var maxZoom;
		//variables for various svg elements
        var countryLine;
        var allButtons;
		var title;
		

        // DEFINE FUNCTIONS/OBJECTS
        // Define map projection
        var newScale = d3
          .geoEquirectangular()
          .center([-115, 20]) // set centre to further North as we are cropping more off bottom of map
          .scale([w / (1.75 * Math.PI)]) // scale to fit group width
          .translate([w / 2, h / 2]) // ensure centred in group
        ;

        // Define map path
        var path = d3
          .geoPath()
          .projection(newScale)
        ;
	  
  	  function parseLatLongData(lines){
  		  return{
  			  countryName: lines["Country"],
  			  latitude : Number(lines["Latitude (average)"]),
  			  longitude: Number(lines["Longitude (average)"]),
  			  iso3code: lines["Alpha-3 Code"]
  		  };
    }

    function getArc(d) {  
        var dx = d[0][0] - d[1][0];
        var dy = d[0][1] - d[1][1];
        var dr = Math.sqrt(dx * dx + dy * dy);
                      //var spath = s == false ? ' 0 0,0 ' : ' 0 0,1 ';
        return 'M' + d[0][0] + ',' + d[0][1] + 'A' + dr + ',' + dr + ' ' + '0 0, 0' + d[1][0] + ',' + d[1][1];
        }

  

        // Create function to apply zoom to countriesGroup
        function zoomed() {
          t = d3
            .event
            .transform
          ;
          countriesGroup
            .attr("transform","translate(" + [t.x, t.y] + ")scale(" + t.k + ")")
          ;
		      if (countryLine != undefined) {
		      countryLine.attr("transform","translate(" + [t.x, t.y] + ")scale(" + t.k + ")");
        	}
        }

        // Define map zoom behaviour
        var zoom = d3
          .zoom()
          .on("zoom", zoomed)
        ;

        function getTextBox(selection) {
          selection
            .each(function(d) {
              d.bbox = this
                .getBBox();
              })
          ;
        }

        // Function that calculates zoom/pan limits and sets zoom to default value 
        function initiateZoom() {
			
			d3.selectAll("#header").remove();
			
  			title = svg
			.append("text")
			.attr("id", "header")
          	.attr("x", ($("#map-holder").width() / 2))             
          	.attr("y", "50")
          	.attr("text-anchor", "middle")  
          	.style("font-size", "40px") 
  			.style("font-family", "Aquifer") 
  			.style("fill", "#360C10")
          	.text("Language and Colonization");
			
          minZoom = Math.max($("#map-holder").width() / w, $("#map-holder").height() / h);
          // set max zoom to a suitable factor of this value
          maxZoom = 20 * minZoom;
          // set extent of zoom to chosen values
          // set translate extent so that panning can't cause map to move out of viewport
          zoom
            .scaleExtent([minZoom, maxZoom])
            .translateExtent([[0, 0], [w, h]])
          ;
          // define X and Y offset for centre of map to be shown in centre of holder
          midX = ($("#map-holder").width() - minZoom * w) / 2;
          midY = ($("#map-holder").height() - minZoom * h) / 2;
          // change zoom transform to min zoom and centre offsets
          svg.call(zoom.transform, d3.zoomIdentity.translate(midX, midY).scale(minZoom))
          drawButton();
        }
		
        function zoomOut() {	
		
			d3.selectAll("#header").remove();
			
  			title = svg
			.append("text")
			.attr("id", "header")
          	.attr("x", ($("#map-holder").width() / 2))             
          	.attr("y", "50")
          	.attr("text-anchor", "middle")  
          	.style("font-size", "40px") 
  			.style("font-family", "Aquifer") 
  			.style("fill", "#360C10")
          	.text("Language and Colonization");
			
			d3.select("#lineGrp").remove();

			d3.selectAll(".country").classed("country-colonized", false);
			d3.selectAll(".country").classed("country-on", false);
          minZoom = Math.max($("#map-holder").width() / w, $("#map-holder").height() / h);
          // set max zoom to a suitable factor of this value
          maxZoom = 20 * minZoom;
          // set extent of zoom to chosen values
          // set translate extent so that panning can't cause map to move out of viewport
          zoom
            .scaleExtent([minZoom, maxZoom])
            .translateExtent([[0, 0], [w, h]])
          ;
          // define X and Y offset for centre of map to be shown in centre of holder
          midX = ($("#map-holder").width() - minZoom * w) / 2;
          midY = ($("#map-holder").height() - minZoom * h) / 2;
          // change zoom transform to min zoom and centre offsets
          svg.transition().duration(500).call(zoom.transform, d3.zoomIdentity.translate(midX, midY).scale(minZoom));
        }

        function drawButton() {
            d3.select("#allButtons").remove();
            allButtons= svg.append("g").attr("id","allButtons") 

            var labels= ['zoom out'];

            //groups for each button (which will hold a rect and text)
                buttonGroups = allButtons.selectAll("g.button")
                                  .data(labels)
                                  .enter()
                      .append("g")
                          .attr("class","button")
                      .style("cursor","pointer")           
                                  .on("click",function(d,i) {
                                      zoomOut();
                                  });
    
            var bWidth= 75;
            var bHeight= 20;
            var bSpace= 10; 
            var x0= $("#map-holder").width()*.88;
            var y0= $("#map-holder").height()*.90;

            buttonGroups.append("rect")
                        .attr("class","buttonRect")
                        .attr("width",bWidth)
                        .attr("height",bHeight)
                        .attr("x",function(d,i) {
                            return x0+(bWidth+bSpace)*i;
                        })
                        .attr("y",y0)
                        .attr("rx",5) 
                        .attr("ry",5)
                        .attr("fill","#6A3937");

            //adding text
            buttonGroups.append("text")
                        .attr("class","buttonText")
                        .attr("font-family","Aquifer")
						.attr("font-size", 13)
                        .attr("x",function(d,i) {
                            return x0 + (bWidth+bSpace)*i + bWidth/2;
                        })
                        .attr("y",y0+bHeight/2)
                        .attr("text-anchor","middle")
                        .attr("dominant-baseline","central")
                        .attr("fill","#360C10")
                        .text(function(d) {return d;});
                  }
                }

		

        // zoom to show a bounding box, with optional additional padding as percentage of box size
        function boxZoom(box, centroid, paddingPerc) {
			
		  d3.selectAll("#header").remove();
			
          minXY = box[0];
          maxXY = box[1];
          // find size of map area defined
          zoomWidth = Math.abs(minXY[0] - maxXY[0]);
          zoomHeight = Math.abs(minXY[1] - maxXY[1]);
          // find midpoint of map area defined
          zoomMidX = centroid[0];
          zoomMidY = centroid[1];
          // increase map area to include padding
          zoomWidth = zoomWidth * (1 + paddingPerc / 100);
          zoomHeight = zoomHeight * (1 + paddingPerc / 100);
          // find scale required for area to fill svg
          maxXscale = $("svg").width() / zoomWidth;
          maxYscale = $("svg").height() / zoomHeight;
          zoomScale = Math.min(maxXscale, maxYscale);
          // handle some edge cases
          // limit to max zoom (handles tiny countries)
          zoomScale = Math.min(zoomScale, maxZoom);
          // limit to min zoom (handles large countries and countries that span the date line)
          zoomScale = Math.max(zoomScale, minZoom);
          // Find screen pixel equivalent once scaled
          offsetX = zoomScale * zoomMidX;
          offsetY = zoomScale * zoomMidY;
          // Find offset to centre, making sure no gap at left or top of holder
          dleft = Math.min(0, $("svg").width() / 2 - offsetX);
          dtop = Math.min(0, $("svg").height() / 2 - offsetY);
          // Make sure no gap at bottom or right of holder
          dleft = Math.max($("svg").width() - w * zoomScale, dleft);
          dtop = Math.max($("svg").height() - h * zoomScale, dtop);
          // set zoom
          svg
            .transition()
            .duration(500)
            .call(
              zoom.transform,
              d3.zoomIdentity.translate(dleft, dtop).scale(zoomScale)
            );
        }

        // on window resize
        $(window).resize(function() {
          // Resize SVG
          svg
            .attr("width", $("#map-holder").width())
            .attr("height", $("#map-holder").height())
          ;
          initiateZoom();
        });

        // create an SVG
        var svg = d3
          .select("#map-holder")
          .append("svg")
          // set to the same size as the "map-holder" div
          .attr("width", $("#map-holder").width())
          .attr("height", $("#map-holder").height())
          // add zoom functionality
          .call(zoom)
        ;
		

        var latLongData;
		
  	d3.csv("Country_Latitude_Longitude.csv", parseLatLongData, function(error, data){
  		rawlatLongData = data;
		latLongData = [];
      	var i = 0;
      	rawlatLongData.forEach(function(){
        latLongData.push({key: rawlatLongData[i].countryName, value: [rawlatLongData[i].longitude, rawlatLongData[i].latitude]});
        i++;
      });

        // get map data
        d3.json(
          "data.geo.json",
          function(json) {
			 
            countriesGroup = svg.append("g").attr("id", "map");
			
            // add a background rectangle
            countriesGroup
              .append("rect")
              .attr("x", 0)
              .attr("y", 0)
              .attr("width", w)
              .attr("height", h);

            // draw a path for each feature/country
            countries = countriesGroup
              .selectAll("path")
              .data(json.features)
              .enter()
              .append("path")
              .attr("d", path)
              .attr("id", function(d, i) {
                return "country" + d.properties.iso_a3;
              })
              .attr("class", "country")
              .attr("stroke-width", 10)
              .attr("stroke", "#ff0000")
              // add a mouseover action to show name label for feature/country
              .on("mouseover", function(d, i) {
                  d3.select("#countryLabel" + d.properties.iso_a3).style("display", "inline-block");
                  tooltip.style("visibility", "visible");

                  function getLanguages(){
                      var i;
                      if (["France", "Spain", "United Kingdom", "Portugal"].includes(d.properties.name)){
                        return "";
                      }
                      for (i = 0; i < americanCountriesWithLang.length; i++) {
                          if (americanCountriesWithLang[i].key == d.properties.name) {
                            var j;
                            var output = "";
                            var no_languages = true;
                            for (j = 0; j < americanCountriesWithLang[i].value.length; j++) {
                              if (j < 30){ // Set the max number of extinct langauges that can be displayed to 30
                                output += "&nbsp&nbsp"+americanCountriesWithLang[i].value[j].split("|")[0];
                                if (americanCountriesWithLang[i].value[j].split("|")[1]=="Vulnerable") {
                                  output += "&nbsp<text class='vulnerable'>&nbsp</text>&nbsp";
                                } else if (americanCountriesWithLang[i].value[j].split("|")[1]=="Definitely endangered") {
                                  output += "&nbsp<text class='definitely-endangered'>&nbsp</text>&nbsp";
                                } else if (americanCountriesWithLang[i].value[j].split("|")[1]=="Severely endangered") {
                                  output += "&nbsp<text class='severely-endangered'>&nbsp</text>&nbsp";
                                } else if (americanCountriesWithLang[i].value[j].split("|")[1]=="Critically endangered") {
                                  output += "&nbsp<text class='critically-endangered'>&nbsp</text>&nbsp";
                                } else if (americanCountriesWithLang[i].value[j].split("|")[1]=="Extinct") {
                                  output += "&nbsp<text class='extinct'>&nbsp</text>&nbsp";
                                }
                                output += americanCountriesWithLang[i].value[j].split("|")[2];
                                output += "<br>";
                              }
                              no_languages = false;
                            }
                            if (no_languages) {
                              return "Loading...";
                            }
                            return output;
                          }
                      }
                  }

                  var languages = getLanguages();
				  
				  //Right now this functionality is not being implemented on purpose
                  if (languages == null){
					  if(d.properties.name == "United Kingdom") {
                    	languages = "Empire from 1583 - 1997";
					}
				  else if (d.properties.name == "France") {
                  	languages = "Empire from 1534 - 1980";
				}
				
			  	 else if (d.properties.name == "Spain") {
                	languages = "Empire from 1492 - 1975";
				}
		  	  else if (d.properties.name == "Portugal") {
              	languages = "Empire from 1415 - 1999";
				}
				else {
					languages = "None";
				}
				
			  }

			  //Display number speakers for empire countries
          if (d.properties.name == "United Kingdom") {
              document.getElementById("info").innerHTML = 
                    d.properties.name+"<br> <br>English Speakers in the World: 1500000000 <br><br>";
          } else if (d.properties.name == "Spain") {
              document.getElementById("info").innerHTML = 
                    d.properties.name+"<br> <br>Spanish Speakers in the World: 500000000 <br><br>";
          } else if (d.properties.name == "Portugal") {
              document.getElementById("info").innerHTML = 
                    d.properties.name+"<br> <br>Portuguese Speakers in the World: 220000000 <br><br>";
          } else if (d.properties.name == "France") {
              document.getElementById("info").innerHTML = 
                    d.properties.name+"<br> <br>French Speakers in the World: 220000000 <br><br>";
          } else {
                document.getElementById("info").innerHTML = 
                    d.properties.name+"<br> <br>"+languages;
          }
                    
              })
              .on("mouseout", function(d, i) {
                  d3.select("#countryLabel" + d.properties.iso_a3).style("display", "none");

		        document.getElementById("info").innerHTML = 
		          "<br> <br>Click on a North or South <br>American country to zoom. <br><br>Hover over one of these <br>countries to see a list of its <br>vulnerable and extinct <br>languages.<br><br>Language vulnerability is <br>indicated by color and the <br>number of speakers left. <br><br><text class='vulnerable'>&nbsp</text> : vulnerable<br><text class='definitely-endangered'>&nbsp</text> : definitely endangered<br><text class='severely-endangered'>&nbsp</text> : severely endangered <br><text class='critically-endangered'>&nbsp</text> : critically endangered<br><text class='extinct'>&nbsp</text> : extinct<br>  <br>Click on a European country <br> to see its colonies.";
              })
              // add an onclick action to zoom into clicked country, and add lines to colonies for empire countries
              .on("click", function(d, i) {
				
  				if (d.properties.name != "United Kingdom" && d.properties.name != "France" && d.properties.name != "Spain" && d.properties.name != "Portugal"
  				&& d.text != "United Kingdom" && d.text != "France" && d.text != "Spain" && d.text != "Portugal") {
                  	d3.selectAll(".country").classed("country-on", false);
                    d3.select(this).classed("country-colonized", false);
                  	d3.select(this).classed("country-on", true);
                  	boxZoom(path.bounds(d), path.centroid(d), 20);
  				}
			     else {
					zoomOut();
					
                  	d3.selectAll(".country").classed("country-on", false);
                  	d3.select(this).classed("country-on", true);
					
					d3.select("#lineGrp").remove();
					
					countryLine = svg.append("g").attr("id", "lineGrp");

          if (d.properties.name == "United Kingdom"){
			  
            var origin = [latLongData[227].value[0], latLongData[227].value[1]];
            var j = 0;
            var destination;
            var connections;
            
              latLongData.forEach(function(){
                  if (rulerAmericas.UK.includes(latLongData[j].key)){
                    destination = [latLongData[j].value[0], latLongData[j].value[1]];
                    connections = [newScale(origin), newScale(destination)];
                    
                    //console.log(rulerAmericas.UK);
                    name_pairs = 
                      { "United States of America" : "#countryUSA",
                        "Canada" : "#countryCAN",
                        "Bahamas" : "#countryBHS",
                        "Jamaica" : "#countryJAM",
                        "Trinidad and Tobago" : "#countryTTO",
                        "Barbados" : "#countryBRB",
                        "Dominica" : "#countryDMA",
                        "Grenada" : "#countryGRD",
                        "Antigua and Barbuda" : "#countryATG",
                        "Belize" : "#countryBLZ"}
                    var i;
                    for (i = 0; i < rulerAmericas.UK.length; i=i+2){
                      //console.log(rulerAmericas.UK[i]);
                       d3.select(name_pairs[rulerAmericas.UK[i]]).classed("country-colonized", true);
                    }

                    countryLine.append("path")
                    .data(connections)
                    .attr('d', function(coordinates) {
                        return getArc(connections);
                        })
                    .style('stroke', 'black')
                    .style('stroke-width', 2)
                    .style('fill', 'none')
                    .transition()
                    .duration(1000)
                    .attrTween('stroke-dasharray', function() {
                      var len = this.getTotalLength();
                      return function(t) {
                        return (d3.interpolate('0,' + len, len + ',0'))(t)
                      };
                    });
                  }
                  j++;
                });
              
            }

          if (d.properties.name == "France"){
            
            var origin = [latLongData[71].value[0], latLongData[71].value[1]];
            var j = 0;
            var destination;
            var connections;
            
              latLongData.forEach(function(){
                  if (rulerAmericas.France.includes(latLongData[j].key)){
                    destination = [latLongData[j].value[0], latLongData[j].value[1]];
                    connections = [newScale(origin), newScale(destination)];
                    
                    //console.log(rulerAmericas.France);

                    name_pairs = 
                      { "Haiti" : "#countryHTI"}
                    var i;
                    for (i = 0; i < rulerAmericas.France.length; i=i+2){
                      //console.log(rulerAmericas.France[i]);
                       d3.select(name_pairs[rulerAmericas.France[i]]).classed("country-colonized", true);
                    }

                    countryLine.append("path")
                    .data(connections)
                    .attr('d', function(coordinates) {
                        return getArc(connections);
                        })
                    .style('stroke', 'black')
                    .style('stroke-width', 2)
                    .style('fill', 'none')
                    .transition()
                    .duration(1000)
                    .attrTween('stroke-dasharray', function() {
                      var len = this.getTotalLength();
                      return function(t) {
                        return (d3.interpolate('0,' + len, len + ',0'))(t)
                      };
                    });
                  }
                  j++;
              });
              
          }

          if (d.properties.name == "Spain"){
            var origin = [latLongData[201].value[0], latLongData[201].value[1]];
            var j = 0;
            var destination;
            var connections;
            
              latLongData.forEach(function(){
                  if (rulerAmericas.Spain.includes(latLongData[j].key)){
                    destination = [latLongData[j].value[0], latLongData[j].value[1]];
                    connections = [newScale(origin), newScale(destination)];
                    
                    //console.log(rulerAmericas.Spain);

                    name_pairs = 
                      { "Cuba" : "#countryCUB",
                        "Dominican Republic" : "#countryDOM",
                        "Mexico" : "#countryMEX",
                        "Guatemala" : "#countryGTM",
                        "Honduras" : "#countryHND",
                        "El Salvador" : "#countrySLV",
                        "Nicaragua" : "#countryNIC",
                        "Costa Rica" : "#countryCRI",
                        "Panama" : "#countryPAN",
                        "Colombia" : "#countryCOL",
                        "Venezuela" : "#countryVEN",
                        "Guyana" : "#countryGUY",
                        "Suriname" : "#countrySUR",
                        "Ecuador" : "#countryECU",
                        "Peru" : "#countryPER",
                        "Bolivia" : "#countryBOL",
                        "Paraguay" : "#countryPRY",
                        "Chile" : "#countryCHL",
                        "Argentina" : "#countryARG",
                        "Uruguay" : "#countryURY"}
                    var i;
                    for (i = 0; i < rulerAmericas.Spain.length; i=i+2){
                      //console.log(rulerAmericas.Spain[i]);
                       d3.select(name_pairs[rulerAmericas.Spain[i]]).classed("country-colonized", true);
                    }

                    countryLine.append("path")
                    .data(connections)
                    .attr('d', function(coordinates) {
                        return getArc(connections);
                        })
                    .style('stroke', 'black')
                    .style('stroke-width', 2)
                    .style('fill', 'none')
                    .transition()
                    .duration(1000)
                    .attrTween('stroke-dasharray', function() {
                      var len = this.getTotalLength();
                      return function(t) {
                        return (d3.interpolate('0,' + len, len + ',0'))(t)
                      };
                    });
                  }
                  j++;
              });
              
          }

          if (d.properties.name == "Portugal"){
            var origin = [latLongData[174].value[0], latLongData[174].value[1]];
            var j = 0;
            var destination;
            var connections;
            
              latLongData.forEach(function(){
                  if (rulerAmericas.Portugal.includes(latLongData[j].key)){
                    destination = [latLongData[j].value[0], latLongData[j].value[1]];
                    connections = [newScale(origin), newScale(destination)];
                    
                    //console.log(rulerAmericas.Portugal);

                     name_pairs = 
                      { "Brazil" : "#countryBRA"}
                    var i;
                    for (i = 0; i < rulerAmericas.Portugal.length; i=i+2){
                      //console.log(rulerAmericas.Portugal[i]);
                       d3.select(name_pairs[rulerAmericas.Portugal[i]]).classed("country-colonized", true);
                    }

                    countryLine.append("path")
                    .data(connections)
                    .attr('d', function(coordinates) {
                        return getArc(connections);
                        })
                    .style('stroke', 'black')
                    .style('stroke-width', 2)
                    .style('fill', 'none')
                    .transition()
                    .duration(1000)
                    .attrTween('stroke-dasharray', function() {
                      var len = this.getTotalLength();
                      return function(t) {
                        return (d3.interpolate('0,' + len, len + ',0'))(t)
                      };
                    });
                  }
                  j++;
              });
  		    }
        }

      });
        
            // Add a label group to each feature/country. This will contain the country name and a background rectangle
            // Use CSS to have class "countryLabel" initially hidden
            countryLabels = countriesGroup
              .selectAll("g")
              .data(json.features)
              .enter()
              .append("g")
              .attr("class", "countryLabel")
              .attr("id", function(d) {
                return "countryLabel" + d.properties.iso_a3;
              })
              .attr("transform", function(d) {
                return (
                  "translate(" + path.centroid(d)[0] + "," + path.centroid(d)[1] + ")"
                );
              })
              // add mouseover functionality to the label
              .on("mouseover", function(d, i) {
                  d3.select("#countryLabel" + d.properties.iso_a3).style("display", "inline-block");
                  tooltip.style("visibility", "visible");

                  function getLanguages(){
                      var i;
                      if (["France", "Spain", "United Kingdom", "Portugal"].includes(d.properties.name)){
                        return "";
                      }
                      for (i = 0; i < americanCountriesWithLang.length; i++) {
                          if (americanCountriesWithLang[i].key == d.properties.name) {
                            var j;
                            var output = "";
                            var no_languages = true;
                            for (j = 0; j < americanCountriesWithLang[i].value.length; j++) {
                              if (j < 30){ // Set the max number of extinct langauges that can be displayed to 30
                                output += "&nbsp&nbsp"+americanCountriesWithLang[i].value[j].split("|")[0];
                                if (americanCountriesWithLang[i].value[j].split("|")[1]=="Vulnerable") {
                                  output += "&nbsp<text class='vulnerable'>&nbsp</text>&nbsp";
                                } else if (americanCountriesWithLang[i].value[j].split("|")[1]=="Definitely endangered") {
                                  output += "&nbsp<text class='definitely-endangered'>&nbsp</text>&nbsp";
                                } else if (americanCountriesWithLang[i].value[j].split("|")[1]=="Severely endangered") {
                                  output += "&nbsp<text class='severely-endangered'>&nbsp</text>&nbsp";
                                } else if (americanCountriesWithLang[i].value[j].split("|")[1]=="Critically endangered") {
                                  output += "&nbsp<text class='critically-endangered'>&nbsp</text>&nbsp";
                                } else if (americanCountriesWithLang[i].value[j].split("|")[1]=="Extinct") {
                                  output += "&nbsp<text class='extinct'>&nbsp</text>&nbsp";
                                }
                                output += americanCountriesWithLang[i].value[j].split("|")[2];
                                output += "<br>";
                              }
                              no_languages = false;
                            }
                            if (no_languages) {
                              return "Loading...";
                            }
                            return output;
                          }
                      }
                  }

                  var languages = getLanguages();
				  
				  //This functionality is not being implemented right now on purpose
                  if (languages == null){
					  if(d.properties.name == "United Kingdom") {
                    	languages = "Empire from 1583 - 1997";
					}
				  else if (d.properties.name == "France") {
                  	languages = "Empire from 1534 - 1980";
				}
				
			  	 else if (d.properties.name == "Spain") {
                	languages = "Empire from 1492 - 1975";
				}
		  	  else if (d.properties.name == "Portugal") {
              	languages = "Empire from 1415 - 1999";
				}
				else {
					languages = "None";
				}
				
			  }

			  //Add number of speakers for empire countries
          if (d.properties.name == "United Kingdom") {
              document.getElementById("info").innerHTML = 
                    d.properties.name+"<br> <br>English Speakers in the World: 1500000000 <br><br>";
          } else if (d.properties.name == "Spain") {
              document.getElementById("info").innerHTML = 
                    d.properties.name+"<br> <br>Spanish Speakers in the World: 500000000 <br><br>";
          } else if (d.properties.name == "Portugal") {
              document.getElementById("info").innerHTML = 
                    d.properties.name+"<br> <br>Portuguese Speakers in the World: 220000000 <br><br>";
          } else if (d.properties.name == "France") {
              document.getElementById("info").innerHTML = 
                    d.properties.name+"<br> <br>French Speakers in the World: 220000000 <br><br>";
          } else {
                document.getElementById("info").innerHTML = 
                    d.properties.name+"<br> <br>"+languages;
          }
                    
              })
              .on("mouseout", function(d, i) {
                   d3.select(this).style("display", "none");
				   
		         document.getElementById("info").innerHTML = 
		           "<br> <br>Click on a North or South <br>American country to zoom. <br><br>Hover over one of these <br>countries to see a list of its <br>vulnerable and extinct <br>languages.<br><br>Language vulnerability is <br>indicated by color and the <br>number of speakers left. <br><br><text class='vulnerable'>&nbsp</text> : vulnerable<br><text class='definitely-endangered'>&nbsp</text> : definitely endangered<br><text class='severely-endangered'>&nbsp</text> : severely endangered <br><text class='critically-endangered'>&nbsp</text> : critically endangered<br><text class='extinct'>&nbsp</text> : extinct<br>  <br>Click on a European country <br> to see its colonies.";
             })
              // add an onlcick action to zoom into clicked country, and lines for empire countries
              .on("click", function(d, i) {
    				if (d.properties.name != "United Kingdom" && d.properties.name != "France" && d.properties.name != "Spain" && d.properties.name != "Portugal"
    				&& d.text != "United Kingdom" && d.text != "France" && d.text != "Spain" && d.text != "Portugal") {

						d3.selectAll(".country").classed("country-on", false);
						d3.select("#country" + d.properties.iso_a3).classed("country-on", true);
						d3.select(this).classed("country-colonized", false);
                   
                    	boxZoom(path.bounds(d), path.centroid(d), 20);
    				}
				
    				else {
                    //d3.select("#country" + d.properties.iso_a3).append()
  					zoomOut();
					
					d3.selectAll(".country").classed("country-on", false);
					d3.select("#country" + d.properties.iso_a3).classed("country-on", true);
					
					d3.select("#lineGrp").remove();
					
					countryLine = svg.append("g").attr("id", "lineGrp");

          if (d.properties.name == "United Kingdom"){
			  
            var origin = [latLongData[227].value[0], latLongData[227].value[1]];
            var j = 0;
            var destination;
            var connections;
            
              latLongData.forEach(function(){
                  if (rulerAmericas.UK.includes(latLongData[j].key)){
                    destination = [latLongData[j].value[0], latLongData[j].value[1]];
                    connections = [newScale(origin), newScale(destination)];
                    
                    //console.log(rulerAmericas.UK);
                    name_pairs = 
                      { "United States of America" : "#countryUSA",
                        "Canada" : "#countryCAN",
                        "Bahamas" : "#countryBHS",
                        "Jamaica" : "#countryJAM",
                        "Trinidad and Tobago" : "#countryTTO",
                        "Barbados" : "#countryBRB",
                        "Dominica" : "#countryDMA",
                        "Grenada" : "#countryGRD",
                        "Antigua and Barbuda" : "#countryATG",
                        "Belize" : "#countryBLZ"}
                    var i;
                    for (i = 0; i < rulerAmericas.UK.length; i=i+2){
                      //console.log(rulerAmericas.UK[i]);
                       d3.select(name_pairs[rulerAmericas.UK[i]]).classed("country-colonized", true);
                    }

                    countryLine.append("path")
                    .data(connections)
                    .attr('d', function(coordinates) {
                        return getArc(connections);
                        })
                    .style('stroke', 'black')
                    .style('stroke-width', 2)
                    .style('fill', 'none')
                    .transition()
                    .duration(1000)
                    .attrTween('stroke-dasharray', function() {
                      var len = this.getTotalLength();
                      return function(t) {
                        return (d3.interpolate('0,' + len, len + ',0'))(t)
                      };
                    });
                  }
                  j++;
                });
              
            }

          if (d.properties.name == "France"){
            
            var origin = [latLongData[71].value[0], latLongData[71].value[1]];
			var j = 0;
            var destination;
            var connections;
            
              latLongData.forEach(function(){
                  if (rulerAmericas.France.includes(latLongData[j].key)){
                    destination = [latLongData[j].value[0], latLongData[j].value[1]];
                    connections = [newScale(origin), newScale(destination)];
                    
                    //console.log(rulerAmericas.France);

                    name_pairs = 
                      { "Haiti" : "#countryHTI"}
                    var i;
                    for (i = 0; i < rulerAmericas.France.length; i=i+2){
                      //console.log(rulerAmericas.France[i]);
                       d3.select(name_pairs[rulerAmericas.France[i]]).classed("country-colonized", true);
                    }

                    countryLine.append("path")
                    .data(connections)
                    .attr('d', function(coordinates) {
                        return getArc(connections);
                        })
                    .style('stroke', 'black')
                    .style('stroke-width', 2)
                    .style('fill', 'none')
                    .transition()
                    .duration(1000)
                    .attrTween('stroke-dasharray', function() {
                      var len = this.getTotalLength();
                      return function(t) {
                        return (d3.interpolate('0,' + len, len + ',0'))(t)
                      };
                    });
                  }
				  j++;
              });
              
          }

          if (d.properties.name == "Spain"){
            var origin = [latLongData[201].value[0], latLongData[201].value[1]];
            var j = 0;
            var destination;
            var connections;
            
              latLongData.forEach(function(){
                  if (rulerAmericas.Spain.includes(latLongData[j].key)){
                    destination = [latLongData[j].value[0], latLongData[j].value[1]];
                    connections = [newScale(origin), newScale(destination)];
                    
                    //console.log(rulerAmericas.Spain);

                    name_pairs = 
                      { "Cuba" : "#countryCUB",
                        "Dominican Republic" : "#countryDOM",
                        "Mexico" : "#countryMEX",
                        "Guatemala" : "#countryGTM",
                        "Honduras" : "#countryHND",
                        "El Salvador" : "#countrySLV",
                        "Nicaragua" : "#countryNIC",
                        "Costa Rica" : "#countryCRI",
                        "Panama" : "#countryPAN",
                        "Colombia" : "#countryCOL",
                        "Venezuela" : "#countryVEN",
                        "Guyana" : "#countryGUY",
                        "Suriname" : "#countrySUR",
                        "Ecuador" : "#countryECU",
                        "Peru" : "#countryPER",
                        "Bolivia" : "#countryBOL",
                        "Paraguay" : "#countryPRY",
                        "Chile" : "#countryCHL",
                        "Argentina" : "#countryARG",
                        "Uruguay" : "#countryURY"}
                    var i;
                    for (i = 0; i < rulerAmericas.Spain.length; i=i+2){
                      //console.log(rulerAmericas.Spain[i]);
                       d3.select(name_pairs[rulerAmericas.Spain[i]]).classed("country-colonized", true);
                    }

                    countryLine.append("path")
                    .data(connections)
                    .attr('d', function(coordinates) {
                        return getArc(connections);
                        })
                    .style('stroke', 'black')
                    .style('stroke-width', 2)
                    .style('fill', 'none')
                    .transition()
                    .duration(1000)
                    .attrTween('stroke-dasharray', function() {
                      var len = this.getTotalLength();
                      return function(t) {
                        return (d3.interpolate('0,' + len, len + ',0'))(t)
                      };
                    });
                  }
                  j++;
              });
              
          }

          if (d.properties.name == "Portugal"){
            var origin = [latLongData[174].value[0], latLongData[174].value[1]];
            var j = 0;
            var destination;
            var connections;
            
              latLongData.forEach(function(){
                  if (rulerAmericas.Portugal.includes(latLongData[j].key)){
                    destination = [latLongData[j].value[0], latLongData[j].value[1]];
                    connections = [newScale(origin), newScale(destination)];
                    
                    //console.log(rulerAmericas.Portugal);

                     name_pairs = 
                      { "Brazil" : "#countryBRA"}
                    var i;
                    for (i = 0; i < rulerAmericas.Portugal.length; i=i+2){
                      //console.log(rulerAmericas.Portugal[i]);
                       d3.select(name_pairs[rulerAmericas.Portugal[i]]).classed("country-colonized", true);
                    }

                    countryLine.append("path")
                    .data(connections)
                    .attr('d', function(coordinates) {
                        return getArc(connections);
                        })
                    .style('stroke', 'black')
                    .style('stroke-width', 2)
                    .style('fill', 'none')
                    .transition()
                    .duration(1000)
                    .attrTween('stroke-dasharray', function() {
                      var len = this.getTotalLength();
                      return function(t) {
                        return (d3.interpolate('0,' + len, len + ',0'))(t)
                      };
                    });
                  }
                  j++;
              });
  		    }
        }
  					

      });

            // add the text to the label group showing country name
            countryLabels
              .append("text")
              .attr("class", "countryName")
              .style("text-anchor", "middle")
              .attr("dx", 0)
              .attr("dy", 0)
              .text(function(d) {
                return d.properties.name;
              })
              .call(getTextBox);
			  
            // add a background rectangle the same size as the text
            countryLabels
              .insert("rect", "text")
              .attr("class", "countryLabelBg")
              .attr("transform", function(d) {
                return "translate(" + (d.bbox.x - 2) + "," + d.bbox.y + ")";
              })
              .attr("width", function(d) {
                return d.bbox.width + 4;
              })
              .attr("height", function(d) {
                return d.bbox.height;
              });
			  
			  //show initial map view
            initiateZoom();

          });
    });


   
    </script>
    
</body>
</html>