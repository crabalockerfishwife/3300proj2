
<!DOCTYPE html>

<!-- Map generation code sourced from -->
<!-- https://medium.com/@andybarefoot/making-a-map-using-d3-js-8aa3637304ee -->

<html>
<head>
    <title> </title>
    <meta charset="utf-8" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/4.5.0/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js"></script>
    <script src="https://d3js.org/d3.v4.min.js"></script>

    <!-- Did not write this stylesheet -->
    <link rel = "stylesheet" type = "text/css" href = "not_written_style.css" />

    <link rel = "stylesheet" type = "text/css" href = "style.css" />
	<script src="https://use.fontawesome.com/releases/v5.0.10/js/all.js" integrity="sha384-slN8GvtUJGnv6ca26v8EzVaR9DC58QEwsIk9q1QXdCU8Yu8ck/tL/5szYlBbqmS+" crossorigin="anonymous"></script>

</head>


<body>
	
    <div id="">
      <p id="">
      </p>
    </div>

	
<div id="map-holder"></div>
    <script src="http://code.jquery.com/jquery-1.10.2.min.js"></script>
    <script src="http://cdn.leafletjs.com/leaflet-0.7.1/leaflet.js"></script>

    
    <script src ="colonialismData.js"></script>
    <script>

        // None of the following is code we wrote! The source is https://medium.com/@andybarefoot/making-a-map-using-d3-js-8aa3637304ee

        var tooltip = d3.select("body")
        .append("div")
        .style("position", "absolute")
        .style("top", "100px")
        .style("z-index", "10")
        .style("visibility", "hidden")
        .text("")
        .attr("id", "info");

        // DEFINE VARIABLES
        // Define size of map group
        // Full world map is 2:1 ratio
        // Using 12:5 because we will crop top and bottom of map
        w = 2500;
        h = 1400;
        // variables for catching min and max zoom factors
        var minZoom;
        var maxZoom;
        var countryLine;
        var allButtons;
		

        // DEFINE FUNCTIONS/OBJECTS
        // Define map projection
        var newScale = d3
          .geoEquirectangular()
          .center([-85, 15]) // set centre to further North as we are cropping more off bottom of map
          .scale([w / (1.75 * Math.PI)]) // scale to fit group width
          .translate([w / 2, h / 2]) // ensure centred in group
        ;

        // Define map path
        var path = d3
          .geoPath()
          .projection(newScale)
        ;
	  
  	  function parseLatLongData(lines){
  	return{
  		countryName: lines["Country"],
  		latitude : Number(lines["Latitude (average)"]),
  		longitude: Number(lines["Longitude (average)"]),
  		iso3code: lines["Alpha-3 Code"]
  	};
    }

    // function pathTween() {

    //   var interpolate = d3.scale.quantile().domain([0,1]).range(d3.range(1, 1000))
    //   return function(t) {
    //     return line(data.slice(0, interpolate(t)));
    //   };
    //   }

    function getArc(d) {  
        var dx = d[0][0] - d[1][0];
        var dy = d[0][1] - d[1][1];
        var dr = Math.sqrt(dx * dx + dy * dy);
                      //var spath = s == false ? ' 0 0,0 ' : ' 0 0,1 ';
        return 'M' + d[0][0] + ',' + d[0][1] + 'A' + dr + ',' + dr + ' ' + '0 0, 0' + d[1][0] + ',' + d[1][1];
        }

  

        // Create function to apply zoom to countriesGroup
        function zoomed() {
          t = d3
            .event
            .transform
          ;
          countriesGroup
            .attr("transform","translate(" + [t.x, t.y] + ")scale(" + t.k + ")")
          ;
		      if (countryLine != undefined) {
		      countryLine.attr("transform","translate(" + [t.x, t.y] + ")scale(" + t.k + ")");
        }
        }

        // Define map zoom behaviour
        var zoom = d3
          .zoom()
          .on("zoom", zoomed)
        ;

        function getTextBox(selection) {
          selection
            .each(function(d) {
              d.bbox = this
                .getBBox();
              })
          ;
        }

        // Function that calculates zoom/pan limits and sets zoom to default value 
        function initiateZoom() {
          // Define a "minzoom" whereby the "Countries" is as small possible without leaving white space at top/bottom or sides
          minZoom = Math.max($("#map-holder").width() / w, $("#map-holder").height() / h);
          // set max zoom to a suitable factor of this value
          maxZoom = 20 * minZoom;
          // set extent of zoom to chosen values
          // set translate extent so that panning can't cause map to move out of viewport
          zoom
            .scaleExtent([minZoom, maxZoom])
            .translateExtent([[0, 0], [w, h]])
          ;
          // define X and Y offset for centre of map to be shown in centre of holder
          midX = ($("#map-holder").width() - minZoom * w) / 2;
          midY = ($("#map-holder").height() - minZoom * h) / 2;
          // change zoom transform to min zoom and centre offsets
          svg.call(zoom.transform, d3.zoomIdentity.translate(midX, midY).scale(minZoom))
          drawButton();
        }
		
        function zoomOut() {
          // Define a "minzoom" whereby the "Countries" is as small possible without leaving white space at top/bottom or sides
          minZoom = Math.max($("#map-holder").width() / w, $("#map-holder").height() / h);
          // set max zoom to a suitable factor of this value
          maxZoom = 20 * minZoom;
          // set extent of zoom to chosen values
          // set translate extent so that panning can't cause map to move out of viewport
          zoom
            .scaleExtent([minZoom, maxZoom])
            .translateExtent([[0, 0], [w, h]])
          ;
          // define X and Y offset for centre of map to be shown in centre of holder
          midX = ($("#map-holder").width() - minZoom * w) / 2;
          midY = ($("#map-holder").height() - minZoom * h) / 2;
          // change zoom transform to min zoom and centre offsets
          svg.transition().duration(500).call(zoom.transform, d3.zoomIdentity.translate(midX, midY).scale(minZoom));
        }

        function drawButton() {
            d3.select("#allButtons").remove();
            allButtons= svg.append("g")
                                .attr("id","allButtons") 

          //var mag = d3.select("#mag").attr("x", $("#map-holder").width()*.88).attr("y",$("#map-holder").height()*.95);
            var labels= ['zoom out'];

            //groups for each button (which will hold a rect and text)
                buttonGroups = allButtons.selectAll("g.button")
                                  .data(labels)
                                  .enter()
                      .append("g")
                          .attr("class","button")
                      .style("cursor","pointer")           
                                  .on("click",function(d,i) {
                                      zoomOut();
                                  });
    
            //button width and height
            var bWidth= 75; //button width
            var bHeight= 20; //button height
            var bSpace= 10; //space between buttons
            var x0= $("#map-holder").width()*.88; //x offset
            var y0= $("#map-holder").height()*.90; //y offset

            //adding a rect to each button group
            //sidenote: rx and ry give the rects rounded corners
            buttonGroups.append("rect")
                        .attr("class","buttonRect")
                        .attr("width",bWidth)
                        .attr("height",bHeight)
                        .attr("x",function(d,i) {
                            return x0+(bWidth+bSpace)*i;
                        })
                        .attr("y",y0)
                        .attr("rx",5) 
                        .attr("ry",5)
                        .attr("fill","#6A3937");

            //adding text to each button group, centered within the button rect
            buttonGroups.append("text")
                        .attr("class","buttonText")
                        .attr("font-family","Font Awesome")
                        .attr("x",function(d,i) {
                            return x0 + (bWidth+bSpace)*i + bWidth/2;
                        })
                        .attr("y",y0+bHeight/2)
                        .attr("text-anchor","middle")
                        .attr("dominant-baseline","central")
                        .attr("fill","#360C10")
                        .text(function(d) {return d;});
      
      
                  var defaultColor= "#BBC5AA";
                  var hoverColor= "#0000ff";
                  var pressedColor= "#000077";
          
                        
                  function updateButtonColors(button, parent) {
                      parent.selectAll("rect")
                              .attr("fill",defaultColor)

                      button.select("rect")
                              .attr("fill",pressedColor)
                  }
                }
		

        // zoom to show a bounding box, with optional additional padding as percentage of box size
        function boxZoom(box, centroid, paddingPerc) {
          minXY = box[0];
          maxXY = box[1];
          // find size of map area defined
          zoomWidth = Math.abs(minXY[0] - maxXY[0]);
          zoomHeight = Math.abs(minXY[1] - maxXY[1]);
          // find midpoint of map area defined
          zoomMidX = centroid[0];
          zoomMidY = centroid[1];
          // increase map area to include padding
          zoomWidth = zoomWidth * (1 + paddingPerc / 100);
          zoomHeight = zoomHeight * (1 + paddingPerc / 100);
          // find scale required for area to fill svg
          maxXscale = $("svg").width() / zoomWidth;
          maxYscale = $("svg").height() / zoomHeight;
          zoomScale = Math.min(maxXscale, maxYscale);
          // handle some edge cases
          // limit to max zoom (handles tiny countries)
          zoomScale = Math.min(zoomScale, maxZoom);
          // limit to min zoom (handles large countries and countries that span the date line)
          zoomScale = Math.max(zoomScale, minZoom);
          // Find screen pixel equivalent once scaled
          offsetX = zoomScale * zoomMidX;
          offsetY = zoomScale * zoomMidY;
          // Find offset to centre, making sure no gap at left or top of holder
          dleft = Math.min(0, $("svg").width() / 2 - offsetX);
          dtop = Math.min(0, $("svg").height() / 2 - offsetY);
          // Make sure no gap at bottom or right of holder
          dleft = Math.max($("svg").width() - w * zoomScale, dleft);
          dtop = Math.max($("svg").height() - h * zoomScale, dtop);
          // set zoom
          svg
            .transition()
            .duration(500)
            .call(
              zoom.transform,
              d3.zoomIdentity.translate(dleft, dtop).scale(zoomScale)
            );
        }




        // on window resize
        $(window).resize(function() {
          // Resize SVG
          svg
            .attr("width", $("#map-holder").width())
            .attr("height", $("#map-holder").height())
          ;
          initiateZoom();
        });

        // create an SVG
        var svg = d3
          .select("#map-holder")
          .append("svg")
          // set to the same size as the "map-holder" div
          .attr("width", $("#map-holder").width())
          .attr("height", $("#map-holder").height())
          // add zoom functionality
          .call(zoom)
        ;
        var latLongData;
  	d3.csv("Country_Latitude_Longitude.csv", parseLatLongData, function(error, data){
  		rawlatLongData = data;
		  latLongData = [];
      var i = 0;
      rawlatLongData.forEach(function(){
        latLongData.push({key: rawlatLongData[i].countryName, value: [rawlatLongData[i].longitude, rawlatLongData[i].latitude]});
        i++;
      });

     
  
        // get map data
        d3.json(
          "data.geo.json",
          function(json) {
            //Bind data and create one path per GeoJSON feature
            countriesGroup = svg.append("g").attr("id", "map");
            // add a background rectangle
            countriesGroup
              .append("rect")
              .attr("x", 0)
              .attr("y", 0)
              .attr("width", w)
              .attr("height", h);

            // draw a path for each feature/country
            countries = countriesGroup
              .selectAll("path")
              .data(json.features)
              .enter()
              .append("path")
              .attr("d", path)
              .attr("id", function(d, i) {
                return "country" + d.properties.iso_a3;
              })
              .attr("class", "country")
              .attr("stroke-width", 10)
              .attr("stroke", "#ff0000")
              // add a mouseover action to show name label for feature/country
              .on("mouseover", function(d, i) {
                  d3.select("#countryLabel" + d.properties.iso_a3).style("display", "inline-block");

                  //I wrote this
                  //svg.append("rect").attr("class", "information").attr("x", "400").attr("y", "400");

                  // End of wrote this block
              })
              .on("mouseout", function(d, i) {
                  d3.select("#countryLabel" + d.properties.iso_a3).style("display", "none");

                  d3.select(".information").style("display", "none");
              })
              // add an onclick action to zoom into clicked country
              .on("click", function(d, i) {
				
  				if (d.properties.name != "United Kingdom" && d.properties.name != "France" && d.properties.name != "Spain" && d.properties.name != "Portugal"
  				&& d.text != "United Kingdom" && d.text != "France" && d.text != "Spain" && d.text != "Portugal") {
                  	d3.selectAll(".country").classed("country-on", false);
                  	d3.select(this).classed("country-on", true);
                  	boxZoom(path.bounds(d), path.centroid(d), 20);
  				}
				
  				else {
					zoomOut();
					
					d3.select("#lineGrp").remove();
					
					countryLine = svg.append("g").attr("id", "lineGrp");

          if (d.properties.name == "United Kingdom"){
            var origin = [latLongData[227].value[0], latLongData[227].value[1]];
            
            

            var j = 0;
            var destination;
            var connections;
            
              latLongData.forEach(function(){
                  if (rulerAmericas.UK.includes(latLongData[j].key)){
                    destination = [latLongData[j].value[0], latLongData[j].value[1]];
                    connections = [newScale(origin), newScale(destination)];
                    

                    countryLine.append("path")
                    .data(connections)
                    .attr('d', function(coordinates) {
                        return getArc(connections);
                        })
                    .style('stroke', 'black')
                    .style('stroke-width', 2)
                    .style('fill', 'none')
                    .transition()
                    .duration(1000)
                    .attrTween('stroke-dasharray', function() {
                      var len = this.getTotalLength();
                      return function(t) {
                        return (d3.interpolate('0,' + len, len + ',0'))(t)
                      };
                    });
                  }

                  //var path = document.querySelector('.path');
                  //var length = path.getTotalLength();


                  j++;
                });
              
            }

          if (d.properties.name == "France"){
            
            var origin = [latLongData[71].value[0], latLongData[71].value[1]];
            
            

            var j = 0;
            var destination;
            var connections;
            
              latLongData.forEach(function(){
                  if (rulerAmericas.France.includes(latLongData[j].key)){
                    destination = [latLongData[j].value[0], latLongData[j].value[1]];
                    connections = [newScale(origin), newScale(destination)];
                    

                    countryLine.append("path")
                    .data(connections)
                    .attr('d', function(coordinates) {
                        return getArc(connections);
                        })
                    .style('stroke', 'black')
                    .style('stroke-width', 2)
                    .style('fill', 'none')
                    .transition()
                    .duration(1000)
                    .attrTween('stroke-dasharray', function() {
                      var len = this.getTotalLength();
                      return function(t) {
                        return (d3.interpolate('0,' + len, len + ',0'))(t)
                      };
                    });
                  }

                  //var path = document.querySelector('.path');
                  //var length = path.getTotalLength();


                  j++;
              });
              
          }

          if (d.properties.name == "Spain"){
            var origin = [latLongData[201].value[0], latLongData[201].value[1]];
            
            

            var j = 0;
            var destination;
            var connections;
            
              latLongData.forEach(function(){
                  if (rulerAmericas.Spain.includes(latLongData[j].key)){
                    destination = [latLongData[j].value[0], latLongData[j].value[1]];
                    connections = [newScale(origin), newScale(destination)];
                    

                    countryLine.append("path")
                    .data(connections)
                    .attr('d', function(coordinates) {
                        return getArc(connections);
                        })
                    .style('stroke', 'black')
                    .style('stroke-width', 2)
                    .style('fill', 'none')
                    .transition()
                    .duration(1000)
                    .attrTween('stroke-dasharray', function() {
                      var len = this.getTotalLength();
                      return function(t) {
                        return (d3.interpolate('0,' + len, len + ',0'))(t)
                      };
                    });
                  }

                  //var path = document.querySelector('.path');
                  //var length = path.getTotalLength();


                  j++;
              });
              
          }

          if (d.properties.name == "Portugal"){
            var origin = [latLongData[174].value[0], latLongData[174].value[1]];
            
            

            var j = 0;
            var destination;
            var connections;
            
              latLongData.forEach(function(){
                  if (rulerAmericas.Portugal.includes(latLongData[j].key)){
                    destination = [latLongData[j].value[0], latLongData[j].value[1]];
                    connections = [newScale(origin), newScale(destination)];
                    

                    countryLine.append("path")
                    .data(connections)
                    .attr('d', function(coordinates) {
                        return getArc(connections);
                        })
                    .style('stroke', 'black')
                    .style('stroke-width', 2)
                    .style('fill', 'none')
                    .transition()
                    .duration(1000)
                    .attrTween('stroke-dasharray', function() {
                      var len = this.getTotalLength();
                      return function(t) {
                        return (d3.interpolate('0,' + len, len + ',0'))(t)
                      };
                    });
                  }

                  //var path = document.querySelector('.path');
                  //var length = path.getTotalLength();


                  j++;
              });
  		    }
        }

      });
        
            // Add a label group to each feature/country. This will contain the country name and a background rectangle
            // Use CSS to have class "countryLabel" initially hidden
            countryLabels = countriesGroup
              .selectAll("g")
              .data(json.features)
              .enter()
              .append("g")
              .attr("class", "countryLabel")
              .attr("id", function(d) {
                return "countryLabel" + d.properties.iso_a3;
              })
              .attr("transform", function(d) {
                return (
                  "translate(" + path.centroid(d)[0] + "," + path.centroid(d)[1] + ")"
                );
              })
              // add mouseover functionality to the label
              .on("mouseover", function(d, i) {
                  d3.select(this).style("display", "block");
              })
              .on("mouseout", function(d, i) {
                   d3.select(this).style("display", "none");
             })
              // add an onlcick action to zoom into clicked country
              .on("click", function(d, i) {
    				if (d.properties.name != "United Kingdom" && d.properties.name != "France" && d.properties.name != "Spain" && d.properties.name != "Portugal"
    				&& d.text != "United Kingdom" && d.text != "France" && d.text != "Spain" && d.text != "Portugal") {
                    	d3.selectAll(".country").classed("country-on", false);
                    	d3.select(this).classed("country-on", true);
                    	boxZoom(path.bounds(d), path.centroid(d), 20);
    				}
				
    				else {
                    //d3.select("#country" + d.properties.iso_a3).append()
  					zoomOut();
					
  					d3.select("#lineGrp").remove();
					
  					countryLine = svg.append("g").attr("id", "lineGrp");
					  if (d.properties.name == "United Kingdom"){
            var origin = [latLongData[227].value[0], latLongData[227].value[1]];
            
            

            var j = 0;
            var destination;
            var connections;
            
              latLongData.forEach(function(){
                  if (rulerAmericas.UK.includes(latLongData[j].key)){
                    destination = [latLongData[j].value[0], latLongData[j].value[1]];
                    connections = [newScale(origin), newScale(destination)];
                    

                    countryLine.append("path")
                    .data(connections)
                    .attr('d', function(coordinates) {
                        return getArc(connections);
                        })
                    .style('stroke', 'black')
                    .style('stroke-width', 2)
                    .style('fill', 'none')
                    .transition()
                    .duration(1000)
                    .attrTween('stroke-dasharray', function() {
                      var len = this.getTotalLength();
                      return function(t) {
                        return (d3.interpolate('0,' + len, len + ',0'))(t)
                      };
                    });
                  }

                  //var path = document.querySelector('.path');
                  //var length = path.getTotalLength();


                  j++;
                });
              
            }

          if (d.properties.name == "France"){
            
            var origin = [latLongData[71].value[0], latLongData[71].value[1]];
            
            

            var j = 0;
            var destination;
            var connections;
            
              latLongData.forEach(function(){
                  if (rulerAmericas.France.includes(latLongData[j].key)){
                    destination = [latLongData[j].value[0], latLongData[j].value[1]];
                    connections = [newScale(origin), newScale(destination)];
                    

                    countryLine.append("path")
                    .data(connections)
                    .attr('d', function(coordinates) {
                        return getArc(connections);
                        })
                    .style('stroke', 'black')
                    .style('stroke-width', 2)
                    .style('fill', 'none')
                    .transition()
                    .duration(1000)
                    .attrTween('stroke-dasharray', function() {
                      var len = this.getTotalLength();
                      return function(t) {
                        return (d3.interpolate('0,' + len, len + ',0'))(t)
                      };
                    });
                  }

                  //var path = document.querySelector('.path');
                  //var length = path.getTotalLength();


                  j++;
              });
              
          }

          if (d.properties.name == "Spain"){
            var origin = [latLongData[201].value[0], latLongData[201].value[1]];
            
            

            var j = 0;
            var destination;
            var connections;
            
              latLongData.forEach(function(){
                  if (rulerAmericas.Spain.includes(latLongData[j].key)){
                    destination = [latLongData[j].value[0], latLongData[j].value[1]];
                    connections = [newScale(origin), newScale(destination)];
                    

                    countryLine.append("path")
                    .data(connections)
                    .attr('d', function(coordinates) {
                        return getArc(connections);
                        })
                    .style('stroke', 'black')
                    .style('stroke-width', 2)
                    .style('fill', 'none')
                    .transition()
                    .duration(1000)
                    .attrTween('stroke-dasharray', function() {
                      var len = this.getTotalLength();
                      return function(t) {
                        return (d3.interpolate('0,' + len, len + ',0'))(t)
                      };
                    });
                  }

                  //var path = document.querySelector('.path');
                  //var length = path.getTotalLength();


                  j++;
              });
              
          }

          if (d.properties.name == "Portugal"){
            var origin = [latLongData[174].value[0], latLongData[174].value[1]];
            
            

            var j = 0;
            var destination;
            var connections;
            
              latLongData.forEach(function(){
                  if (rulerAmericas.Portugal.includes(latLongData[j].key)){
                    destination = [latLongData[j].value[0], latLongData[j].value[1]];
                    connections = [newScale(origin), newScale(destination)];
                    

                    countryLine.append("path")
                    .data(connections)
                    .attr('d', function(coordinates) {
                        return getArc(connections);
                        })
                    .style('stroke', 'black')
                    .style('stroke-width', 2)
                    .style('fill', 'none')
                    .transition()
                    .duration(1000)
                    .attrTween('stroke-dasharray', function() {
                      var len = this.getTotalLength();
                      return function(t) {
                        return (d3.interpolate('0,' + len, len + ',0'))(t)
                      };
                    });
                  }

                  //var path = document.querySelector('.path');
                  //var length = path.getTotalLength();


                  j++;
              });
          }
        }

      });

            // add the text to the label group showing country name
            countryLabels
              .append("text")
              .attr("class", "countryName")
              .style("text-anchor", "middle")
              .attr("dx", 0)
              .attr("dy", 0)
              .text(function(d) {
                return d.properties.name;
              })
              .call(getTextBox);
            // add a background rectangle the same size as the text
            countryLabels
              .insert("rect", "text")
              .attr("class", "countryLabelBg")
              .attr("transform", function(d) {
                return "translate(" + (d.bbox.x - 2) + "," + d.bbox.y + ")";
              })
              .attr("width", function(d) {
                return d.bbox.width + 4;
              })
              .attr("height", function(d) {
                return d.bbox.height;
              });
            initiateZoom();




          });
    });




   
    </script>

</body>
</html>